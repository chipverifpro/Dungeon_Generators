using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;
using System.Collections;
using System.Linq;
using System;
using NUnit.Framework;

/* DONE list...
-- DONE; Round world including fast oval room bounds checking
-- DONE: Nested Perlin / Stacked Perlin
-- DONE: Filter small wall areas
-- DONE: 3D walls
-- DONE: Code cleanup for organization and optimization
-- DONE: Use Rooms list to draw 3D, not a copy of the 2D map.
   (allows corridors above/below rooms)
-- DONE: Clamp ramp slopes at 1.
-- DONE: Don't draw diagonals when 3 walls on one tile.

   TODO list...
-- Simplex Noise
-- Presets of interesting dungeons - menu or random selection
-- Adding extra corridors to break up tree
-- Dirty MapArray, dirty Hashes, smarter hashes
-- More tile types: stairs, doors, traps (with properties)
-- Fix early regeneration button (abort in-progress)
-- Fix pulldown after recompile
-- Don't show build progress option implementation
-- Enforce minimum width room connectivity
-- Walkthrough capability
-- Camera flight controls
-- Reorganize files
-- Use more intelligent yielding to accomplish more each refresh.
-- Multi-layer map generation
-- Fix corridors between stacked rooms
-- Ceiling hight minimum and room merging
-- Gently sloping floors without stairs (perlin heights)
-- Change long 3D routines to coroutines.
 */

// Master Dungeon Generation Class...
public partial class DungeonGenerator : MonoBehaviour
{
    public DungeonSettings cfg; // Configurable settings for project

    // References to game components (set in Unity Inspector)
    public HeightMap3DBuilder heightBuilder;
    public Tilemap tilemap;
    public TileBase floorTile;
    public TileBase wallTile;
    // ---------------------------------------------------------------
    // Different ways to store the map: room(list of points) and mapArray (grid of bytes)
    public List<Room> rooms = new(); // Master List of rooms including list of points and metadata

    public List<RectInt> room_rects = new(); // List of RectInt rooms for ScatterRooms
    public List<int> room_rects_heights = new(); // List of heights for each room rectangle
    public HashSet<Vector2Int> floor_hash_map = new();
    public HashSet<Vector2Int> wall_hash_map = new();
    public byte[,] map; // each byte represents one of the below constants
    public int[,] mapHeights; // 2D array to store height information for each tile
    public bool mapStale = true; // Flag to indicate if map needs to be regenerated from rooms
    [HideInInspector] public const byte WALL = 1;
    [HideInInspector] public const byte FLOOR = 2;
    [HideInInspector] public const byte RAMP = 3;
    [HideInInspector] public const byte UNKNOWN = 99;
    // Additional tile types to be defined here

    public List<Color> room_rects_color = new();

    // Reference to CellularAutomata component for variables and methods there
    private CellularAutomata ca;

    // ------------------------------------- //
    // Start is called by Unity before the first frame update
    public void Start()
    {
        // Initialize randomizer either with preselected seed, or one generated by clock
        if (cfg.randomizeSeed) cfg.seed = (int)DateTime.Now.Ticks;
        UnityEngine.Random.InitState(cfg.seed);
        Debug.Log("DungeonGenerator starting with seed: " + cfg.seed);

        // Get reference to CellularAutomata component
        ca = GetComponent<CellularAutomata>();
        if (ca == null)
        {
            Debug.LogError("CellularAutomata component not found. Please add it to the DungeonGenerator GameObject.");
            Application.Quit();
        }

        // Start the fun...

        StartCoroutine(RegenerateDungeon(null));
    }

    // RegenerateDungeon is the main coroutine that handles dungeon generation.
    // It orchestrates the various steps involved in creating the dungeon layout.
    // Step 0: Select settings
    // Step 1: Initialize the dungeon
    // Step 2: Place rooms (ScatterRooms or CellularAutomata)
    // Step 3: Convert rooms to a list of floor tiles (ConvertRectToRoomPoints or findRoomTiles for CA)
    // Step 4: Combine overlapping rooms (MergeOverlappingRooms)
    // Step 5: Connect rooms by corridors (DrawCorridors)

    // Other routines:
    //  Draw Map by Rooms
    //  Draw Walls

    public IEnumerator RegenerateDungeon(TimeTask tm = null)
    {
        bool local_tm = false;
        if (tm==null) {tm = TimeManager.Instance.BeginTask("RegenerateDungeon"); local_tm = true;}
        try
        {
            room_rects = new List<RectInt>(); // Clear the list of room rectangles
            mapHeights = new int[cfg.mapWidth, cfg.mapHeight];
            heightBuilder.Destroy3D();
            if (tm.IfYield()) yield return null;     // cooperative yield decision
            BottomBanner.Show("Generating dungeon...");

            // Step 0: Select settings
            switch (cfg.RoomAlgorithm) // Change this to select different algorithms
            {
                case DungeonSettings.RoomAlgorithm_e.Scatter_Overlap:
                    cfg.generateOverlappingRooms = true;
                    cfg.useCellularAutomata = false;
                    cfg.useScatterRooms = true;
                    tavern.enabled = false;
                    break;
                case DungeonSettings.RoomAlgorithm_e.Scatter_NoOverlap:
                    cfg.generateOverlappingRooms = false;
                    cfg.useCellularAutomata = true;
                    cfg.useScatterRooms = true;
                    tavern.enabled = false;
                    break;
                case DungeonSettings.RoomAlgorithm_e.CellularAutomata:
                    cfg.useCellularAutomata = true;
                    cfg.useScatterRooms = false;
                    cfg.usePerlin = false; // Disable Perlin for CA
                    tavern.enabled = false;
                    break;
                case DungeonSettings.RoomAlgorithm_e.CellularAutomataPerlin:
                    cfg.useCellularAutomata = true;
                    cfg.useScatterRooms = false;
                    cfg.usePerlin = true; // Enable Perlin for CA
                    tavern.enabled = false;
                    break;
                case DungeonSettings.RoomAlgorithm_e.Tavern:
                    tavern.enabled = true;
                    cfg.useCellularAutomata = false;
                    cfg.useScatterRooms = false;
                    break;
            }

            BottomBanner.Show("Initialize dungeon...");


            // ===== Step 1. Initialize the dungeon
            tilemap.ClearAllTiles();
            rooms.Clear();
            map = new byte[cfg.mapWidth, cfg.mapHeight];
            FillVoidToWalls(map);
            yield return tm.YieldOrDelay(cfg.stepDelay);

            // ===== Step 2. Place rooms

            // TAVERN
            if (tavern.enabled)
            {
                yield return StartCoroutine(BuildTavern(tm: null));
            }

            if (cfg.useCellularAutomata) // Cellular Automata generation
            {
                BottomBanner.Show("Cellular Automata cavern generation iterating...");
                yield return StartCoroutine(ca.RunCaveGeneration(tm: null));
                DrawWalls();
            }
            if (cfg.useScatterRooms)
            {
                BottomBanner.Show("Scattering rooms...");
                yield return StartCoroutine(ScatterRooms(tm: null));
                Debug.Log("ScatterRooms done, room_rects.Count = " + room_rects.Count);
                DrawMapByRects(room_rects, room_rects_color);
                DrawWalls();
            }

            yield return tm.YieldOrDelay(cfg.stepDelay);

            // Step 3: Combine overlapping rooms
            BottomBanner.Show("Locate Discrete rooms...");
            if (cfg.useCellularAutomata) // locate rooms from cellular automata
            {
                BottomBanner.Show("Remove tiny rocks...");
                yield return StartCoroutine(ca.RemoveTinyRocksCoroutine(tm: null));

                BottomBanner.Show("Remove tiny rooms...");
                yield return StartCoroutine(ca.RemoveTinyRoomsCoroutine(tm: null));

                // For Cellular Automata, find rooms from the map
                BottomBanner.Show("Locate Discrete rooms...");
                yield return StartCoroutine(ca.FindRoomsCoroutine(map, tm: null));
            }
            if (cfg.useScatterRooms)
            {
                rooms = ConvertAllRectToRooms(room_rects, room_rects_color, SetTile: true);
                DrawMapByRooms(rooms);
                DrawWalls();
                if (tm.IfYield()) yield return null;     // cooperative yield decision

                yield return tm.YieldOrDelay(cfg.stepDelay);
                // Step 4: Merge overlapping rooms
                BottomBanner.Show("Merging Overlapping Rooms...");
                if (cfg.MergeScatteredRooms)
                    rooms = MergeOverlappingRooms(rooms, considerAdjacency: true, eightWay: false);
                DrawMapByRooms(rooms);
                DrawWalls();
                yield return tm.YieldOrDelay(cfg.stepDelay); // depends on cfg.showBuildProcess
            }

            if (cfg.useCellularAutomata || cfg.useScatterRooms)
            {
                DrawMapByRooms(rooms);
                DrawWalls();

                // Step 5: Connect rooms with corridors
                yield return StartCoroutine(GenerateMapHashes(tm: null)); // no wall data yet, so only does floor hashes
                BottomBanner.Show("Connecting Rooms with Corridors...");
                yield return StartCoroutine(ca.ConnectRoomsByCorridors(tm: null));

                DrawMapByRooms(rooms);
                DrawWalls();
                yield return tm.YieldOrDelay(cfg.stepDelay);
            }

            yield return StartCoroutine(GenerateMapHashes(tm: null)); // no wall data yet, so only does floor hashes
            GenerateWallLists(); // needs floor hashes to run
            yield return StartCoroutine(GenerateMapHashes(tm: null)); // run again to create wall hashes

            BottomBanner.Show("Height Map Build...");

            // FillVoidToWalls(map);
            yield return StartCoroutine(heightBuilder.Build3DFromRooms(tm: null));
                    // If Build should be static, change its definition to 'public static void Build(...)' in HeightMap3DBuilder.

            yield return tm.YieldOrDelay(cfg.stepDelay);

            BottomBanner.ShowFor("Dungeon generation complete!", 5f);
        }
        finally { if(local_tm) tm.End(); }

        TimeManager.Instance.DumpStats();
    }

    // Scatter rooms performs the main room placement for Rectangular or Oval rooms
    IEnumerator ScatterRooms(TimeTask tm=null)
    {
        bool local_tm = false;
        if (tm==null) {tm = TimeManager.Instance.BeginTask("ScatterRooms"); local_tm = true;}
        try
        {
            //List<Vector2Int> roomPoints = new List<Vector2Int>();
            tilemap.ClearAllTiles();
            room_rects.Clear(); // Clear the list of room rectangles
            room_rects_color.Clear(); // Clear the list of colors for room rectangles
            RectInt newRoom = new();
            //rooms.Clear();
            BottomBanner.Show($"Scattering {cfg.roomsMax} Rooms...");
            for (int i = 0; room_rects.Count < cfg.roomsMax && i < cfg.roomAttempts; i++)
            {
                bool fits = false;
                while (fits == false)
                {
                    int w = UnityEngine.Random.Range(cfg.minRoomSize, cfg.maxRoomSize + 1);
                    int h = UnityEngine.Random.Range(cfg.minRoomSize, cfg.maxRoomSize + 1);
                    int x = UnityEngine.Random.Range(1, cfg.mapWidth - w - 1);
                    int y = UnityEngine.Random.Range(1, cfg.mapHeight - h - 1);
                    newRoom = new(x, y, w, h);
                    fits = RoomFitsWorld(newRoom, 32, 0.5f);
                }

                // Check if the new room overlaps with existing rooms
                bool overlaps = false;
                foreach (var r in room_rects)
                {
                    RectInt big_r = new(r.xMin - 1, r.yMin - 1, r.width + 2, r.height + 2);
                    if (newRoom.Overlaps(big_r))
                    {
                        overlaps = true;
                    }
                }

                if (!overlaps || cfg.generateOverlappingRooms)
                {
                    var newColor = UnityEngine.Random.ColorHSV(0f, 1f, 0.6f, 1f, 0.6f, 1f);
                    room_rects.Add(newRoom);
                    room_rects_color.Add(newColor);
                    DrawRect(newRoom, newColor);
                    //                roomPoints = ConvertRectToRoomPoints(newRoom, SetTile: true);
                    //                rooms.Add(new Room(roomPoints));
                    //                rooms[rooms.Count - 1].Name = "Room " + rooms.Count;
                    Debug.Log("Created " + room_rects.Count() + " room_rects");
                    yield return tm.YieldOrDelay(cfg.stepDelay/3);
                }
            }
            Debug.Log("room_rects.Count = " + room_rects.Count);
            yield return tm.YieldOrDelay(cfg.stepDelay);
        }
        finally { if(local_tm) tm.End(); }
    }

    List<Room> ConvertAllRectToRooms(List<RectInt> room_rects, List<Color> room_rects_color, bool SetTile)
    {
        List<Vector2Int> PointsList;
        List<int> HeightsList = new();
        List<Room> rooms = new List<Room>();
        Debug.Log("Converting " + room_rects.Count + " Rects to Rooms...");
        for (int i = 0; i < room_rects.Count; i++)
        {
            var room_rect = room_rects[i];
            var room_rect_color = room_rects_color[i];
            PointsList = ConvertRectToRoomPoints(room_rect, room_rect_color, false/*SetTile*/);
            HeightsList = new();
            for (int h = 0; h < PointsList.Count; h++) HeightsList.Add(i);
            Room room = new Room(PointsList, HeightsList);
            room.isCorridor = false; // Default to false, can be set later if needed
            room.Name = "Room " + (rooms.Count + 1);
            room.setColorFloor(room_rect_color);
            rooms.Add(room);
            DrawMapByRooms(rooms);
            Debug.Log($"ConvertRectsToRooms: room {i} height = {room.heights[0]}");
        }
        return rooms;
    }

    // ConvertRectToRoomPoints generates a list of points within the
    //  given room rectangle or oval.
    // As a side effect, it can also set the corresponding tiles in the tilemap.
    List<Vector2Int> ConvertRectToRoomPoints(RectInt room_rect, Color room_rect_color, bool SetTile)
    {
        //BottomBanner.Show($"Measuring rooms...");
        List<Vector2Int> roomPoints = new List<Vector2Int>();
        for (int x = room_rect.xMin; x < room_rect.xMax; x++)
        {
            for (int y = room_rect.yMin; y < room_rect.yMax; y++)
            {
                if (IsPointInRoomRectOrOval(new Vector2Int(x, y), room_rect))
                {
                    roomPoints.Add(new Vector2Int(x, y));
                    if (SetTile)
                    {
                        tilemap.SetTile(new Vector3Int(x, y, 0), floorTile);
                        tilemap.SetTileFlags(new Vector3Int(x, y, 0), TileFlags.None); // Allow color changes
                        tilemap.SetColor(new Vector3Int(x, y, 0), room_rect_color); // Set default color
                    }
                }
            }
        }
        return roomPoints;
    }

    public void DrawMapByRects(List<RectInt> room_rects, List<Color> colors)
    {
        for (int i = 0; i < room_rects.Count; i++)
        {
            var room_rect = room_rects[i];
            var color = colors[i];
            Debug.Log("Drawing Rect " + room_rect);
            DrawRect(room_rect, color);
        }
    }

    public void DrawRect(RectInt room_rect, Color tempcolor)
    {
        Debug.Log("Drawing Rect ");
        //Color tempcolor = UnityEngine.Random.ColorHSV(0f, 1f, 0.6f, 1f, 0.6f, 1f); // Bright Random
        for (int x = room_rect.xMin; x < room_rect.xMax; x++)
        {
            for (int y = room_rect.yMin; y < room_rect.yMax; y++)
            {
                if (IsPointInRoomRectOrOval(new Vector2Int(x, y), room_rect))
                {
                    tilemap.SetTile(new Vector3Int(x, y, 0), floorTile);
                    tilemap.SetTileFlags(new Vector3Int(x, y, 0), TileFlags.None); // Allow color changes
                    tilemap.SetColor(new Vector3Int(x, y, 0), tempcolor);

                    map[x, y] = FLOOR;
                }
            }
        }
    }

    public void DrawMapByRooms(List<Room> rooms)
    {
        //Debug.Log("Drawing Map by " + rooms.Count + " rooms...");
        tilemap.ClearAllTiles();
        foreach (var room in rooms)
        {
            //Debug.Log("Drawing " + room.Name + " size: " + room.tiles.Count);
            foreach (var point in room.tiles)
            {
                tilemap.SetTile(new Vector3Int(point.x, point.y, 0), floorTile);
                tilemap.SetTileFlags(new Vector3Int(point.x, point.y, 0), TileFlags.None); // Allow color changes
                tilemap.SetColor(new Vector3Int(point.x, point.y, 0), room.colorFloor); // Set room color

                map[point.x, point.y] = FLOOR;
                mapHeights[point.x, point.y] = ca.GetHeightOfLocationFromAllRooms(rooms, point);
            }
        }
    }

    public Room DrawCorridorSloped(Vector2Int start, Vector2Int end, int start_height, int end_height)
    {
        List<Vector2Int> path;
        HashSet<Vector2Int> hashPath = new();
        Room room = new();

        switch (cfg.TunnelsAlgorithm)
        {
            case DungeonSettings.TunnelsAlgorithm_e.TunnelsOrthographic:
                BottomBanner.Show("Drawing orthogonal corridors...");
                path = GridedLine(start, end);
                break;
            case DungeonSettings.TunnelsAlgorithm_e.TunnelsStraight:
                BottomBanner.Show("Drawing straight corridors...");
                path = BresenhamLine(start.x, start.y, end.x, end.y);
                break;
            case DungeonSettings.TunnelsAlgorithm_e.TunnelsOrganic:
                BottomBanner.Show("Drawing organic corridors...");
                path = OrganicLine(start, end);
                break;
            case DungeonSettings.TunnelsAlgorithm_e.TunnelsCurved:
                BottomBanner.Show("Drawing curved corridors...");
                path = GetComponent<BezierDraw>().DrawBezierCorridor(start, end);
                break;
            default:
                BottomBanner.Show("Drawing Bresenham corridors...");
                path = BresenhamLine(start.x, start.y, end.x, end.y);
                break;
        }

        int path_length = path.Count;
        float delta_h = (float)(end_height - start_height) / (float)path_length;
        if (Math.Abs(delta_h) > 1f)
        {
            Debug.Log($"Slope of corridor is too great Abs({delta_h}) > 1");
            delta_h = Math.Clamp(delta_h, -1f, 1f); // Don't allow ramps too steep to climb.
            // Should we generate a new corridor that is longer? TODO
        }

        //Debug.Log("Drawing corridor length " + path.Count + " from " + start + " to " + end + " width " + cfg.corridorWidth + " using " + cfg.TunnelsAlgorithm);
        Debug.Log("Corridor: start_height=" + start_height + " end_height=" + end_height + " length=" + path_length);
        int brush_neg = -cfg.corridorWidth / 2;
        int brush_pos = brush_neg + cfg.corridorWidth;

        //foreach (Vector2Int point in path)
        for (int i = 0; i < path.Count; i++)
        {
            Vector2Int point = path[i];
            int height = start_height + (int)Math.Round(i * delta_h);
            // Square brush around each line point
            for (int dx = brush_neg; dx < brush_pos; dx++)
            {
                for (int dy = brush_neg; dy < brush_pos; dy++)
                {
                    Vector3Int tilePos = new Vector3Int(point.x + dx, point.y + dy, 0);
                    if (tilePos.x < 0 || tilePos.x >= cfg.mapWidth || tilePos.y < 0 || tilePos.y >= cfg.mapHeight)
                    {
                        continue; // Skip out-of-bounds tiles
                    }
                    tilemap.SetTile(tilePos, floorTile);
                    if (hashPath.Add(new Vector2Int(tilePos.x, tilePos.y)))
                    {
                        room.tiles.Add(new Vector2Int(tilePos.x, tilePos.y));
                        room.heights.Add(height);
                    }

                    map[tilePos.x, tilePos.y] = FLOOR; //Floor
                    mapHeights[tilePos.x, tilePos.y] = height;
                }
            }
        }
        room.isCorridor = true;
        return room;
    }

    // --------- Corridor line algorithms ----------
    // These return a list of points, which the DrawCorrior function will follow
    // while handling the width and slope to generate a corridor Room:
    // Gridded (orthogonal)
    // Bresenham (straight)
    // Noisy Bresenham (slightly wiggly)
    // Organic (kinda jiggles while going 45 degrees and then vertical or horizontal)
    // Bezier (curved, implemented in it's own file)

    // Grided Line algorithm: creates an orthogonal line between two points.
    // Randomly starts with either x or y direction and makes just one turn.
    public List<Vector2Int> GridedLine(Vector2Int from, Vector2Int to)
    {
        List<Vector2Int> line = new List<Vector2Int>();
        Vector2Int current = from;
        bool xFirst = UnityEngine.Random.Range(0, 2) == 0;

        if (xFirst)
        {
            // Move in x direction first
            while (current.x != to.x)
            {
                //tilemap.SetTile(new Vector3Int(current.x, current.y, 0), floorTile);
                line.Add(new Vector2Int(current.x, current.y));
                current.x += current.x < to.x ? 1 : -1;
            }
        }
        // Move in y direction
        while (current.y != to.y)
        {
            //tilemap.SetTile(new Vector3Int(current.x, current.y, 0), floorTile);
            line.Add(new Vector2Int(current.x, current.y));
            current.y += current.y < to.y ? 1 : -1;
        }
        // Move in x direction
        while (current.x != to.x)
        {
            //tilemap.SetTile(new Vector3Int(current.x, current.y, 0), floorTile);
            line.Add(new Vector2Int(current.x, current.y));
            current.x += current.x < to.x ? 1 : -1;
        }
        return line;
    }

    // Bresenham's Line algorithm: creates a straight line between two points.
    public List<Vector2Int> BresenhamLine(int x0, int y0, int x1, int y1)
    {
        List<Vector2Int> line = new List<Vector2Int>();

        int dx = Mathf.Abs(x1 - x0);
        int dy = Mathf.Abs(y1 - y0);
        int sx = x0 < x1 ? 1 : -1;
        int sy = y0 < y1 ? 1 : -1;
        int err = dx - dy;

        while (true)
        {
            line.Add(new Vector2Int(x0, y0));
            if (x0 == x1 && y0 == y1) break;

            int e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x0 += sx; }
            if (e2 < dx) { err += dx; y0 += sy; }
        }

        return line;
    }

    // Noisy Bresenham's Line algorithm: creates a straight line between two points with added jiggle noise.
    public List<Vector2Int> NoisyBresenham(Vector2Int start, Vector2Int end)
    {
        List<Vector2Int> path = new List<Vector2Int>();
        float noiseStrength = cfg.organicJitterChance;
        int x0 = start.x;
        int y0 = start.y;
        int x1 = end.x;
        int y1 = end.y;

        int dx = Mathf.Abs(x1 - x0);
        int dy = Mathf.Abs(y1 - y0);
        int sx = x0 < x1 ? 1 : -1;
        int sy = y0 < y1 ? 1 : -1;
        int err = dx - dy;

        while (true)
        {
            path.Add(new Vector2Int(x0, y0));
            if (x0 == x1 && y0 == y1) break;

            int e2 = 2 * err;

            // Add UnityEngine.Random noise to the decision
            float noise = UnityEngine.Random.Range(-1f, 1f) * noiseStrength;

            if (e2 + noise > -dy)
            {
                err -= dy;
                x0 += sx;
            }

            if (e2 + noise < dx)
            {
                err += dx;
                y0 += sy;
            }

            // Always force at least one step to avoid infinite loop
            if (x0 == path[path.Count - 1].x && y0 == path[path.Count - 1].y)
            {
                if (dx > dy)
                    x0 += sx;
                else
                    y0 += sy;
            }
        }

        return path;
    }

    // Organic Line algorithm: creates a wiggly line between two points.
    // Tends to first do a 45 degree diagonal and then switches to horizontal or vertical.
    // Not too bad for short lines as the jagginess is good.
    public List<Vector2Int> OrganicLine(Vector2Int start, Vector2Int end)
    {
        List<Vector2Int> path = new List<Vector2Int>();
        Vector2Int current = start;

        while (current != end)
        {
            path.Add(current);

            Vector2Int direction = end - current;
            int dx = Mathf.Clamp(direction.x, -1, 1);
            int dy = Mathf.Clamp(direction.y, -1, 1);

            // Introduce a slight chance to “wiggle”
            if (UnityEngine.Random.value < cfg.organicJitterChance)
            {
                if (UnityEngine.Random.value < 0.5f)
                    //dx = 0; // favor y
                    dx = UnityEngine.Random.value < 0.5f ? -1 : 1; // favor y
                else
                    //dy = 0; // favor x
                    dy = UnityEngine.Random.value < 0.5f ? -1 : 1; // favor y
            }

            current += new Vector2Int(dx, dy);
        }

        path.Add(end);
        return path;
    }

    // ---------------- End Corridor line algorithms ----------------

    public void DrawWalls()  // from tilemap, adds walls to the existing tilemap
    {
        BoundsInt bounds = tilemap.cellBounds;
        //BottomBanner.Show("Drawing walls...");
        for (int x = bounds.xMin - 1; x <= bounds.xMax + 1; x++)
        {
            for (int y = bounds.yMin - 1; y <= bounds.yMax + 1; y++)
            {
                Vector3Int pos = new(x, y, 0);
                if (tilemap.GetTile(pos) == floorTile)
                    continue;                       // Skip floor tiles
                if (HasFloorNeighbor(pos))
                    tilemap.SetTile(pos, wallTile); // add wall tile
                else
                    tilemap.SetTile(pos, null);     // Remove wall if no floor neighbor
            }
        }
    }

    // Check if a tile at position pos has a neighboring floor tile within the specified radius
    bool HasFloorNeighbor(Vector3Int pos, int radius = 1)
    {
        if (tilemap == null || floorTile == null) return false; // Safety check

        // Check all neighbors within the specified radius
        NeighborCache.Shape shape = cfg.neighborShape;
        bool includeDiagonals = cfg.includeDiagonals;
        var neighbors = NeighborCache.Get(radius, shape, borderOnly: true, includeDiagonals);

        foreach (var offset in neighbors)
        {
            Vector3Int neighborPos = pos + offset;
            if (tilemap.GetTile(neighborPos) == floorTile)
            {
                return true; // Found a floor tile neighbor
            }
        }
        return false; // No floor tile neighbors found
    }

    bool IsPointInRoomRectOrOval(Vector2Int point, RectInt room_rect)
    {
        // start by checking the rectangular bounds
        bool isInRect = (point.x >= room_rect.xMin && point.x < room_rect.xMax
                        && point.y >= room_rect.yMin && point.y < room_rect.yMax);

        if (!isInRect) return false; // outside rectangular bounds for either shape
        if (cfg.ovalRooms == false) return true; // inside rectangular room bounds

        // Check if the point is within the ellipse defined by the room
        float centerX = room_rect.xMin + room_rect.width / 2f;
        float centerY = room_rect.yMin + room_rect.height / 2f;
        float radiusX = room_rect.width / 2f;
        float radiusY = room_rect.height / 2f;

        return Mathf.Pow((point.x - centerX) / radiusX, 2) + Mathf.Pow((point.y - centerY) / radiusY, 2) <= 1;
    }

    // point bounds checking for rectangular or oval world maps
    public bool IsPointInWorld(Vector2Int point)
    {
        if (point.x < 0 || point.y < 0 ||
            point.x > cfg.mapWidth || point.y > cfg.mapHeight)
            return false; // out of the world
        if (!cfg.roundWorld) return true; // square world, limits are sufficient

        // Round world (axis-aligned ellipse) inscribed in the map.
        Vector2 Cw = new Vector2(cfg.mapWidth * 0.5f, cfg.mapHeight * 0.5f);
        float margin = 0.5f; // hardcoded
        float Rx = cfg.mapWidth * 0.5f - margin;
        float Ry = cfg.mapHeight * 0.5f - margin;
        float Rx2 = Rx * Rx, Ry2 = Ry * Ry;
        float dx = point.x - Cw.x, dy = point.y - Cw.y;
        return ((dx * dx) / Rx2 + (dy * dy) / Ry2) <= 1f; // <= 1 means inside world ellipse
    }

    // Returns true if the proposed room bounds fit inside the world according to config flags.
    // (1) cfg.ovalRooms   — RectInt room treated as an inscribed axis-aligned ellipse when true.
    // (2) cfg.roundWorld — world bounds are an axis-aligned ellipse inscribed in the map when true;
    //                       otherwise world is the rectangular map.
    // "samples" controls boundary sampling for oval-in-oval; "margin" shrinks world a bit to avoid edge bleed.
    // 
    // Works for: Rect in Rect, Oval in Rect, Rect in Oval, and Oval in Oval.
    bool RoomFitsWorld(RectInt roomRect, int samples = 32, float margin = 0.5f)
    {
        // Quick early-reject: roomRect must at least fit inside the map rectangle.
        // works for all room shapes and map shapes.
        if (roomRect.xMin < 0 || roomRect.yMin < 0 ||
                    roomRect.xMax > cfg.mapWidth || roomRect.yMax > cfg.mapHeight)
            return false;

        // Any shape in a rectangular world:
        if (!cfg.roundWorld)
        {
            return true; // already proved it fits the map rectangle
        }

        // Round world (axis-aligned ellipse) inscribed in the map.
        Vector2 Cw = new Vector2(cfg.mapWidth * 0.5f, cfg.mapHeight * 0.5f);
        float Rx = cfg.mapWidth * 0.5f - margin;
        float Ry = cfg.mapHeight * 0.5f - margin;
        float Rx2 = Rx * Rx, Ry2 = Ry * Ry;

        float UnitCircle(Vector2 p)
        {
            float dx = p.x - Cw.x, dy = p.y - Cw.y;
            return (dx * dx) / Rx2 + (dy * dy) / Ry2; // <= 1 means inside world ellipse
        }

        if (cfg.ovalRooms) // oval room in oval world:
        {
            // Room is an axis-aligned ellipse inscribed in the rect
            Vector2 Cr = new Vector2(roomRect.xMin + roomRect.width * 0.5f,
                                    roomRect.yMin + roomRect.height * 0.5f);
            float rx = roomRect.width * 0.5f;
            float ry = roomRect.height * 0.5f;

            // Sample boundary n times, reject on any violation
            for (int i = 0; i < samples; i++)
            {
                float t = (2f * Mathf.PI * i) / samples;
                Vector2 p = Cr + new Vector2(rx * Mathf.Cos(t), ry * Mathf.Sin(t));
                if (UnitCircle(p) > 1f) return false;
            }
            return true;
        }
        else // rectangular room in oval world:
        {
            // Room is a rectangle: checking corners is exact for axis-aligned containment in an ellipse space
            float cx = roomRect.xMin + roomRect.width * 0.5f;
            float cy = roomRect.yMin + roomRect.height * 0.5f;
            float hx = roomRect.width * 0.5f;
            float hy = roomRect.height * 0.5f;

            Vector2 c1 = new Vector2(cx - hx, cy - hy);
            Vector2 c2 = new Vector2(cx + hx, cy - hy);
            Vector2 c3 = new Vector2(cx - hx, cy + hy);
            Vector2 c4 = new Vector2(cx + hx, cy + hy);

            return UnitCircle(c1) <= 1f && UnitCircle(c2) <= 1f &&
                UnitCircle(c3) <= 1f && UnitCircle(c4) <= 1f;
        }
    }

    void GenerateWallLists()
    {
        List<Vector2Int> wall_list_room;
        HashSet<Vector2Int> new_wall_hash;

        Vector2Int[] directions = {
            Vector2Int.up, Vector2Int.down,
            Vector2Int.left, Vector2Int.right
        };

        for (int room_number = 0; room_number < rooms.Count; room_number++)
        {
            wall_list_room = new();
            new_wall_hash = new();
            foreach (Vector2Int pos in rooms[room_number].tiles)
            {
                foreach (Vector2Int dir in directions)
                {
                    //if (!floor_hash_map.Contains(pos + dir))
                    if (!rooms[room_number].floor_hash_neighborhood.Contains(pos + dir))
                    {
                        if (new_wall_hash.Add(pos + dir))
                        {
                            wall_list_room.Add(pos + dir);
                        }
                    }
                }
            }
            rooms[room_number].walls = wall_list_room; // Save to rooms[].walls
        }
    }

    // Run GenerateMapHashes() once all rooms are created.
    // Allows quickly looking up room contents from world xy position.
    IEnumerator GenerateMapHashes(TimeTask tm = null)
    {
        bool local_tm = false;
        if (tm==null) {tm = TimeManager.Instance.BeginTask("GenerateMapHashes"); local_tm = true;}
        try
        {
            // Initialize whole-map hashes
            floor_hash_map = new();
            wall_hash_map = new();

            // generate the per-room floor and wall hashes
            for (int room_number = 0; room_number < rooms.Count; room_number++)
            {
                // create per-room hashes
                rooms[room_number].floor_hash_room = new HashSet<Vector2Int>(rooms[room_number].tiles);
                rooms[room_number].wall_hash_room = new HashSet<Vector2Int>(rooms[room_number].walls);

                // Accumulate whole-map hashes
                floor_hash_map.UnionWith(rooms[room_number].floor_hash_room);
                wall_hash_map.UnionWith(rooms[room_number].wall_hash_room);

                if (tm.IfYield()) yield return null;
            }

            // Generate the neighborhood floor and wall hashes
            // (neighborhood means the room and it's directly connected neighbor rooms)
            for (int room_number = 0; room_number < rooms.Count; room_number++)
            {
                // Start with the room itself
                rooms[room_number].floor_hash_neighborhood = new HashSet<Vector2Int>(rooms[room_number].floor_hash_room);
                rooms[room_number].wall_hash_neighborhood = new HashSet<Vector2Int>(rooms[room_number].wall_hash_room);
                // Add the direct neighbors
                for (int neighbor_index = 0; neighbor_index < rooms[room_number].neighbors.Count; neighbor_index++)
                {
                    int neighbor_num = rooms[room_number].neighbors[neighbor_index];
                    rooms[room_number].floor_hash_neighborhood.UnionWith(rooms[neighbor_num].floor_hash_room);
                    rooms[room_number].wall_hash_neighborhood.UnionWith(rooms[neighbor_num].wall_hash_room);
                }
                if (tm.IfYield()) yield return null;
            }
        }
        finally { if(local_tm) tm.End(); }
    }

    public void FillVoidToWalls(byte[,] map)
    {
        for (var y = 0; y < cfg.mapHeight; y++)
            for (var x = 0; x < cfg.mapWidth; x++)
            {
                if (map[x, y] == 0) map[x, y] = WALL;
            }
    }


    /// <summary>
    /// Merge rooms that overlap (share at least one tile).
    /// If considerAdjacency is true, rooms that touch by edge/corner are merged too.
    /// </summary>
    /// <param name="rooms">Input rooms (each has List<Vector2Int> tiles)</param>
    /// <param name="considerAdjacency">If true, merge when tiles are neighbors (4- or 8-connected)</param>
    /// <param name="eightWay">If adjacency is considered, choose 4-way or 8-way</param>
    public static List<Room> MergeOverlappingRooms(List<Room> rooms, bool considerAdjacency = false, bool eightWay = true)
    {
        //BottomBanner.Show("Merging overlapping rooms...");
        if (rooms == null || rooms.Count == 0) return new List<Room>();

        var dsu = new DSU(rooms.Count);
        var owner = new Dictionary<Vector2Int, int>(1024);

        // Optional neighbor offsets for adjacency merging
        Vector2Int[] n4 = new[]
        {
            new Vector2Int( 1, 0),
            new Vector2Int(-1, 0),
            new Vector2Int( 0, 1),
            new Vector2Int( 0,-1)
        };
        Vector2Int[] n8 = new[]
        {
            new Vector2Int( 1, 0), new Vector2Int(-1, 0), new Vector2Int(0, 1), new Vector2Int(0,-1),
            new Vector2Int( 1, 1), new Vector2Int( 1,-1), new Vector2Int(-1, 1), new Vector2Int(-1,-1)
        };
        var neighbors = eightWay ? n8 : n4;

        // 1) Scan all tiles, union rooms that share tiles (overlap)
        for (int i = 0; i < rooms.Count; i++)
        {
            var tiles = rooms[i].tiles;
            for (int k = 0; k < tiles.Count; k++)
            {
                var t = tiles[k];

                if (!owner.TryGetValue(t, out int j))
                {
                    owner[t] = i; // first time we see this tile, claim it
                }
                else
                {
                    // tile already owned by room j => overlap with i
                    dsu.Union(i, j);
                }

                // 2) Optional: adjacency-based merging (touching rooms)
                if (considerAdjacency)
                {
                    foreach (var d in neighbors)
                    {
                        var n = t + d;
                        if (owner.TryGetValue(n, out int kOwner))
                            dsu.Union(i, kOwner);
                    }
                }
            }
        }

        // 3) Fold tiles into their root groups while PRESERVING order and height pairing
        var groupedTiles = new Dictionary<int, List<Vector2Int>>();
        var groupedHeights = new Dictionary<int, List<int>>();
        var groupedSeen = new Dictionary<int, HashSet<Vector2Int>>();

        for (int i = 0; i < rooms.Count; i++)
        {
            int root = dsu.Find(i);
            if (!groupedTiles.ContainsKey(root))
            {
                groupedTiles[root] = new List<Vector2Int>(rooms[i].tiles.Count);
                groupedHeights[root] = new List<int>(rooms[i].tiles.Count);
                groupedSeen[root] = new HashSet<Vector2Int>();
            }

            var rTiles = rooms[i].tiles;
            var rHeights = rooms[i].heights; // may be null or shorter

            for (int k = 0; k < rTiles.Count; k++)
            {
                var t = rTiles[k];
                if (!groupedSeen[root].Add(t))
                    continue; // skip duplicates while preserving first-seen order

                int h = 0;
                if (rHeights != null && rHeights.Count > k)
                    h = rHeights[k];

                groupedTiles[root].Add(t);
                groupedHeights[root].Add(h);
            }
        }

        // 4) Emit merged rooms with preserved tile/height order
        var merged = new List<Room>(groupedTiles.Count);
        foreach (var root in groupedTiles.Keys)
        {
            var newRoom = new Room(groupedTiles[root], groupedHeights[root]);
            newRoom.setColorFloor(highlight: true);
            merged.Add(newRoom);
        }

        // (Optional) sort by size descending like your existing code
        merged.Sort((a, b) => b.Size.CompareTo(a.Size));
        return merged;
    }

}
    //} // End class DungeonGenerator

// ================================================= //

//public static class RoomMergeUtil
//{
// Simple Union-Find/Disjoint Set (DSU=Disjoint Set Union)
class DSU
{
    int[] parent;
    int[] rank;

    public DSU(int n)
    {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
    }

    public int Find(int x)
    {
        if (parent[x] != x) parent[x] = Find(parent[x]);
        return parent[x];
    }

    public void Union(int a, int b)
    {
        a = Find(a); b = Find(b);
        if (a == b) return;
        if (rank[a] < rank[b]) parent[a] = b;
        else if (rank[a] > rank[b]) parent[b] = a;
        else { parent[b] = a; rank[a]++; }
    }

}